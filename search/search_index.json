{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Documentation for the Delta Operating System and it's constituent parts.</p>"},{"location":"docs/kernel/boot/init/","title":"init","text":""},{"location":"docs/kernel/boot/init/#error-codes","title":"Error codes","text":"<p>When init fails to spawn, one of 12 error codes will be present:</p> code meaning 1 Failed to open init path. This usually means that either the cmdline path is incorrect, the file does not exist or there is no initrd (see kernel/boot/initrd) 2 Failed to allocate buffer for the init (OOM) 3 Failed to read the init binary into the buffer 4 Invalid init file (not an executable) 5 Failed to create the init process for it to run on 6 Failed to load the executable onto the process 7 Failed to open the interpreter (dynamic exe only) 8 Failed to allocate interpreter (dynamic exe only) 9 Invalid interpreter file (not an executable) (dynamic exe only) 10 Failed to load interpreter onto the process (dynamic exe only) 11 Failed to allocate process stack 12 Failed to create user thread for process entry"},{"location":"docs/kernel/boot/initrd/","title":"initrd","text":"<p>The initrd is a DeltaArchive file, it's location specified by the delboot.cfg file on disk.</p>"},{"location":"docs/kernel/boot/initrd/#loading-the-initrdda","title":"Loading the initrd.da","text":"<p>The initrd is passed by the bootloader using the DB_TAG_INITRD tag. It is then parsed during late-boot (after platform-specific and driver init), and it requires <code>tmpfs</code> to be mounted on the <code>$files</code> namespace.</p>"},{"location":"docs/wm/protocol/","title":"Window Manager protocol","text":"<p>CREATE -&gt; CONFIGURE -&gt; (RESIZE)* -&gt; COMMIT -&gt; (DESTROY|crash)</p>"},{"location":"specs/archive/","title":"Delta Archive Format (DA)","text":""},{"location":"specs/archive/#overview","title":"Overview","text":"<p>DA is a simple archive format for DeltaOS, designed primarily for initramfs. Optimized for fast sequential parsing during early boot when heap may be limited.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  DA Header (magic, version, counts)     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Entry Table                            \u2502\n\u2502  - Entry 0 (path offset, size, type...) \u2502\n\u2502  - Entry 1                              \u2502\n\u2502  - ...                                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  String Table (paths, null-terminated)  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  File Data (concatenated, aligned)      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"specs/archive/#data-types","title":"Data Types","text":"<p>All multi-byte integers are little-endian.</p> Type Size Description <code>u8</code> 1 byte Unsigned 8-bit <code>u16</code> 2 bytes Unsigned 16-bit LE <code>u32</code> 4 bytes Unsigned 32-bit LE <code>u64</code> 8 bytes Unsigned 64-bit LE"},{"location":"specs/archive/#da-header","title":"DA Header","text":"<pre><code>struct da_header {\n    u32 magic;          // 0x44410001 ('D' 'A' 0x00 0x01)\n    u32 checksum;       // CRC32 of header+entry table (with this field as 0)\n    u16 version;        // Format version (0x0001)\n    u16 flags;          // Archive flags\n    u32 entry_count;    // Number of entries\n    u32 entry_off;      // Offset to entry table\n    u32 strtab_off;     // Offset to string table\n    u32 strtab_size;    // Size of string table\n    u32 data_off;       // Offset to file data section\n    u64 total_size;     // Total uncompressed size of all file data\n};\n</code></pre> <p>Size: 40 bytes</p>"},{"location":"specs/archive/#magic","title":"Magic","text":"<p><code>0x44410001</code>: - <code>0x44</code> = 'D' - <code>0x41</code> = 'A' - <code>0x00</code> = separator - <code>0x01</code> = version</p>"},{"location":"specs/archive/#flags","title":"Flags","text":"Bit Name Description 0 <code>DA_FLAG_SORTED</code> Entries sorted by path (enables binary search) 1 <code>DA_FLAG_HASHED</code> Path hashes included for fast lookup"},{"location":"specs/archive/#entry-table","title":"Entry Table","text":"<p>Each entry describes a file, directory, or symlink.</p> <pre><code>struct da_entry {\n    u32 path_off;       // Offset in string table to path\n    u32 flags;          // Entry flags (type, reserved bits)\n    u64 data_off;       // Offset from data section start (0 for dirs)\n    u64 size;           // Size in bytes (0 for directories)\n    u32 hash;           // Path hash (for fast lookup, optional)\n    u32 reserved;       // Must be zero\n};\n</code></pre> <p>Size: 32 bytes</p>"},{"location":"specs/archive/#entry-flags","title":"Entry Flags","text":"<pre><code>Bits 0-3:   Type\nBits 4-31:  Reserved (must be zero, future: permissions)\n</code></pre>"},{"location":"specs/archive/#entry-types","title":"Entry Types","text":"Value Name Description 0 <code>DA_TYPE_FILE</code> Regular file 1 <code>DA_TYPE_DIR</code> Directory 2 <code>DA_TYPE_LINK</code> Symbolic link <p>For symlinks, <code>data_off</code> points to the target path in the string table.</p>"},{"location":"specs/archive/#string-table","title":"String Table","text":"<p>Null-terminated paths, stored consecutively. All paths are: - Absolute (start with <code>/</code>) - Normalized (no <code>.</code>, <code>..</code>, or trailing slashes) - UTF-8 encoded</p> <p>Example: <pre><code>Offset 0:   \"/\\0\"\nOffset 2:   \"/bin\\0\"\nOffset 7:   \"/bin/init\\0\"\nOffset 17:  \"/etc\\0\"\n...\n</code></pre></p>"},{"location":"specs/archive/#file-data-section","title":"File Data Section","text":"<p>File contents concatenated sequentially. Each file's data starts at: <pre><code>data_section_start + entry.data_off\n</code></pre></p> <p>Alignment: Each file's data is aligned to 8 bytes within the data section. Padding bytes (value 0) are inserted as needed.</p>"},{"location":"specs/archive/#parsing-algorithm","title":"Parsing Algorithm","text":"<pre><code>int da_parse(void *archive, size_t size) {\n    struct da_header *hdr = archive;\n\n    // Verify magic\n    if (hdr-&gt;magic != 0x44410001) return -1;\n\n    // Get tables\n    struct da_entry *entries = archive + hdr-&gt;entry_off;\n    char *strtab = archive + hdr-&gt;strtab_off;\n    void *data = archive + hdr-&gt;data_off;\n\n    // Iterate entries\n    for (u32 i = 0; i &lt; hdr-&gt;entry_count; i++) {\n        struct da_entry *e = &amp;entries[i];\n        const char *path = strtab + e-&gt;path_off;\n        u32 type = e-&gt;flags &amp; 0xF;\n\n        if (type == DA_TYPE_DIR) {\n            create_directory(path);\n        } else if (type == DA_TYPE_FILE) {\n            void *content = data + e-&gt;data_off;\n            create_file(path, content, e-&gt;size);\n        } else if (type == DA_TYPE_LINK) {\n            const char *target = strtab + e-&gt;data_off;\n            create_symlink(path, target);\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"specs/archive/#path-hashing-optional","title":"Path Hashing (Optional)","text":"<p>When <code>DA_FLAG_HASHED</code> is set, the <code>hash</code> field contains a 32-bit FNV-1a hash of the path for O(1) average lookup:</p> <pre><code>u32 da_hash(const char *path) {\n    u32 hash = 0x811c9dc5;  // FNV offset basis\n    while (*path) {\n        hash ^= (u8)*path++;\n        hash *= 0x01000193;  // FNV prime\n    }\n    return hash;\n}\n</code></pre> <p>[!WARNING] Hash is for filtering, not matching. Always verify the actual path string after a hash match to handle collisions: <pre><code>if (entry-&gt;hash == target_hash &amp;&amp; strcmp(path, target) == 0) { found! }\n</code></pre></p>"},{"location":"specs/archive/#comparison-to-other-formats","title":"Comparison to Other Formats","text":"Feature DA CPIO TAR ZIP Header size 40B 76-110B 512B 30B+ Random access Yes No No Yes Stream-readable Yes* Yes Yes No Stream-writable No Yes Yes No Path hashing Yes No No No Compression No No No Yes Complexity Low Medium Low High <p>*Requires reading entry table into memory first; data section is streamable</p>"},{"location":"specs/archive/#tool-darc","title":"Tool: <code>darc</code>","text":"<p>The <code>darc</code> utility creates and extracts DA archives:</p> <pre><code># Create archive from directory\ndarc create initramfs.da /path/to/root\n\n# List contents\ndarc list initramfs.da\n\n# Extract to directory  \ndarc extract initramfs.da /output/path\n\n# Show info\ndarc info initramfs.da\n</code></pre>"},{"location":"specs/archive/#security-notes","title":"Security Notes","text":"<p>Loaders MUST validate all offsets before use:</p> <pre><code>// Bounds checking example\nif (e-&gt;path_off &gt;= hdr-&gt;strtab_size) return -EINVAL;\nif (strtab[hdr-&gt;strtab_size - 1] != '\\0') return -EINVAL;  // ensure null-terminated\nif (e-&gt;data_off + e-&gt;size &gt; archive_size - hdr-&gt;data_off) return -EINVAL;\n</code></pre> <p>[!CAUTION] Never trust offsets from untrusted archives. A malicious archive could point <code>path_off</code> or <code>data_off</code> outside valid bounds, causing out-of-bounds reads.</p>"},{"location":"specs/archive/#notes","title":"Notes","text":"<ul> <li>No compression: Keep the format simple; compression handled externally (bootloader)</li> <li>No timestamps: Not needed for initramfs (all files \"born\" at boot)</li> <li>No UIDs/GIDs: DeltaOS uses capability-based security, not Unix users</li> <li>Sorted entries: Enables binary search for path lookups</li> <li>8-byte alignment: Efficient for 64-bit systems</li> <li>&gt;4GB support: <code>data_off</code> is u64, allowing archives larger than 4GB</li> <li>Tool-created: DA requires knowing all entries upfront (not stream-writable like tar/cpio).   Use <code>darc</code> tool to create archives; kernel only reads them.</li> <li>Header-only checksum: CRC32 covers header + entry table only, not file data.   Bootloader already verifies module integrity; re-checksumming 200MB in early boot is wasteful.</li> </ul>"},{"location":"specs/boot/","title":"Delta Boot Protocol","text":""},{"location":"specs/boot/#overview","title":"Overview","text":"<p>The DB protocol defines:</p> <ol> <li>DB Request Header \u2014 Embedded in the kernel binary, tells the bootloader what's needed</li> <li>DB Boot Info \u2014 Passed to the kernel at boot, contains system information as tags</li> </ol> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    KERNEL BINARY                             \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  DB Request Header (magic + version + flags)           \u2502  \u2502\n\u2502  \u2502  Request Tags: what the kernel wants from bootloader   \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                           \u2502\n                           \u25bc bootloader reads &amp; prepares\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    DB BOOT INFO                              \u2502\n\u2502  Passed to kernel entry point (pointer in arch-defined reg)  \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502  Info Header                                           \u2502  \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502\n\u2502  \u2502  Tag: Memory Map                                       \u2502  \u2502\n\u2502  \u2502  Tag: Framebuffer                                      \u2502  \u2502\n\u2502  \u2502  Tag: Command Line                                     \u2502  \u2502\n\u2502  \u2502  Tag: ...                                              \u2502  \u2502\n\u2502  \u2502  Tag: End                                              \u2502  \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"specs/boot/#data-types","title":"Data Types","text":"<p>All multi-byte integers are little-endian=</p> Type Size Description <code>u8</code> 1 byte Unsigned 8-bit <code>u16</code> 2 bytes Unsigned 16-bit LE <code>u32</code> 4 bytes Unsigned 32-bit LE <code>u64</code> 8 bytes Unsigned 64-bit LE"},{"location":"specs/boot/#part-1-db-request-header","title":"Part 1: DB Request Header","text":"<p>The kernel embeds this header to identify itself as DB-compliant and request features.</p>"},{"location":"specs/boot/#location","title":"Location","text":"<p>The bootloader scans the first 32 KiB of the kernel binary for the magic number, Header must be 8-byte aligned.</p>"},{"location":"specs/boot/#structure","title":"Structure","text":"<pre><code>struct db_request_header {\n    u32 magic;          // 0x44420001 ('D' 'B' 0x00 0x01)\n    u32 checksum;       // CRC32 of header + tags (with this field as 0)\n    u16 version;        // Protocol version (0x0001 for v0.1)\n    u16 header_size;    // Size of this header + all request tags\n    u32 flags;          // Request flags (see below)\n    u32 entry_point;    // Offset (not address!) of kernel entry point\n                        // Relative to start of loaded kernel image\n                        // Use 0xFFFFFFFF if bootloader should use format-specific entry\n};\n// Followed by request tags (until header_size is reached)\n</code></pre> <p>Magic breakdown: <code>0x44420001</code> - <code>0x44</code> = 'D' - <code>0x42</code> = 'B' - <code>0x00</code> = null separator - <code>0x01</code> = format version</p>"},{"location":"specs/boot/#checksum","title":"Checksum","text":"<p>The <code>checksum</code> field contains a CRC32 (polynomial <code>0xEDB88320</code>) computed over the entire header including request tags, with the <code>checksum</code> field itself treated as zero during computation.</p> <p>To compute: 1. Set <code>checksum</code> to 0 2. Calculate CRC32 over bytes <code>[0, header_size)</code> 3. Store result in <code>checksum</code></p> <p>To verify: 1. Save <code>checksum</code> value 2. Set <code>checksum</code> to 0 3. Calculate CRC32 over bytes <code>[0, header_size)</code> 4. Compare with saved value</p>"},{"location":"specs/boot/#request-flags","title":"Request Flags","text":"Bit Name Description 0 <code>DB_REQ_FRAMEBUFFER</code> Kernel requests framebuffer info 1 <code>DB_REQ_MEMORY_MAP</code> Kernel requests memory map (should always be set) 2 <code>DB_REQ_MODULES</code> Kernel supports loaded modules 3 <code>DB_REQ_ACPI</code> Kernel requests ACPI RSDP pointer 4 <code>DB_REQ_CMDLINE</code> Kernel accepts command line 5 <code>DB_REQ_SMP</code> Kernel requests SMP info (CPU count, etc.) 6 <code>DB_REQ_INITRD</code> Kernel requests initial ramdisk 7 <code>DB_REQ_HAS_TAGS</code> Request tags follow the header 8-31 Reserved Must be zero"},{"location":"specs/boot/#flags-and-tags-precedence","title":"Flags and Tags Precedence","text":"<ul> <li>Flag set, no tag: Bootloader provides the feature with default values</li> <li>Flag set, tag present: Bootloader uses tag values (tag refines the request)</li> <li>Flag not set, tag present: Tag is ignored (flag must be set to enable feature)</li> </ul>"},{"location":"specs/boot/#part-1b-request-tags","title":"Part 1b: Request Tags","text":"<p>Request tags allow the kernel to specify detailed requirements beyond simple flags. They immediately follow the request header and are included in <code>header_size</code>.</p>"},{"location":"specs/boot/#request-tag-structure","title":"Request Tag Structure","text":"<pre><code>struct db_request_tag {\n    u16 type;           // Request tag type\n    u16 flags;          // Tag-specific flags\n    u32 size;           // Total size of this tag (including header)\n    // Tag-specific data follows\n};\n</code></pre> <p>Alignment: Each request tag starts at a 4-byte aligned offset from header start</p>"},{"location":"specs/boot/#request-tag-types","title":"Request Tag Types","text":"Type Name Description 0x0000 <code>DB_RTAG_END</code> End of request tag list 0x0001 <code>DB_RTAG_FRAMEBUFFER_PREF</code> Preferred framebuffer settings 0x0002 <code>DB_RTAG_MIN_MEMORY</code> Minimum memory requirement 0x0003 <code>DB_RTAG_LOAD_ADDRESS</code> Preferred/required load address 0x0004 <code>DB_RTAG_STACK_SIZE</code> Requested initial stack size 0x0005 <code>DB_RTAG_ARCH_FEATURES</code> Architecture-specific feature requests"},{"location":"specs/boot/#db_rtag_framebuffer_pref-0x0001","title":"DB_RTAG_FRAMEBUFFER_PREF (0x0001)","text":"<p>Specify preferred framebuffer resolution and pixel format.</p> <pre><code>struct db_rtag_framebuffer_pref {\n    u16 type;           // 0x0001\n    u16 flags;          // Bit 0: required (fail if unavailable)\n    u32 size;           // 28\n    u32 min_width;      // Minimum acceptable width (0 = any)\n    u32 min_height;     // Minimum acceptable height (0 = any)\n    u32 preferred_width;  // Preferred width (0 = any)\n    u32 preferred_height; // Preferred height (0 = any)\n    u8  min_bpp;        // Minimum bits per pixel (0 = any)\n    u8  preferred_bpp;  // Preferred bpp (0 = any)\n    u8  padding[2];\n};\n</code></pre>"},{"location":"specs/boot/#db_rtag_min_memory-0x0002","title":"DB_RTAG_MIN_MEMORY (0x0002)","text":"<p>Specify minimum RAM requirement.</p> <pre><code>struct db_rtag_min_memory {\n    u16 type;           // 0x0002\n    u16 flags;          // 0\n    u32 size;           // 16\n    u64 min_bytes;      // Minimum usable RAM required\n};\n</code></pre>"},{"location":"specs/boot/#db_rtag_load_address-0x0003","title":"DB_RTAG_LOAD_ADDRESS (0x0003)","text":"<p>Request a specific load address (hint or requirement).</p> <pre><code>struct db_rtag_load_address {\n    u16 type;           // 0x0003\n    u16 flags;          // Bit 0: required (fail if unavailable)\n    u32 size;           // 24\n    u64 preferred_addr; // Preferred physical load address\n    u64 alignment;      // Required alignment (must be power of 2)\n};\n</code></pre>"},{"location":"specs/boot/#db_rtag_stack_size-0x0004","title":"DB_RTAG_STACK_SIZE (0x0004)","text":"<p>Request initial kernel stack size.</p> <pre><code>struct db_rtag_stack_size {\n    u16 type;           // 0x0004\n    u16 flags;          // 0\n    u32 size;           // 16\n    u64 stack_size;     // Requested stack size in bytes (0 = bootloader default)\n};\n</code></pre>"},{"location":"specs/boot/#part-2-db-boot-info","title":"Part 2: DB Boot Info","text":"<p>Prepared by the bootloader and passed to the kernel.</p>"},{"location":"specs/boot/#passing-convention","title":"Passing Convention","text":"<p>The bootloader passes a pointer to <code>db_boot_info</code> in an architecture-defined register:</p> Architecture Register Notes x86 (32-bit) <code>EBX</code> Physical address x86_64 <code>RDI</code> Physical address (first arg) ARM32 <code>R0</code> Physical address AArch64 <code>X0</code> Physical address RISC-V <code>A0</code> Physical address"},{"location":"specs/boot/#info-header-structure","title":"Info Header Structure","text":"<pre><code>struct db_boot_info {\n    u32 magic;          // 0x44424F4B ('D' 'B' 'O' 'K' \u2014 \"DB OK\")\n    u32 total_size;     // Total size of boot info including all tags\n    u32 version;        // Protocol version\n    u32 reserved;       // Must be zero\n};\n// Immediately followed by tags\n</code></pre>"},{"location":"specs/boot/#part-3-tags","title":"Part 3: Tags","text":"<p>Tags are variable-length structures that follow the header.</p>"},{"location":"specs/boot/#tag-structure","title":"Tag Structure","text":"<pre><code>struct db_tag {\n    u16 type;           // Tag type identifier\n    u16 flags;          // Tag-specific flags\n    u32 size;           // Total size of this tag (including header)\n    // Tag-specific data follows\n};\n</code></pre> <p>Alignment: Each tag starts at an 8-byte aligned address. Padding: Bootloader inserts padding bytes (value 0) between tags as needed.</p>"},{"location":"specs/boot/#tag-types","title":"Tag Types","text":"Type Name Description 0x0000 <code>DB_TAG_END</code> End of tag list 0x0001 <code>DB_TAG_CMDLINE</code> Command line string 0x0002 <code>DB_TAG_MEMORY_MAP</code> System memory map 0x0003 <code>DB_TAG_FRAMEBUFFER</code> Framebuffer information 0x0004 <code>DB_TAG_MODULES</code> Loaded modules (generic) 0x0005 <code>DB_TAG_ACPI_RSDP</code> ACPI RSDP pointer 0x0006 <code>DB_TAG_SMP</code> SMP/CPU information 0x0007 <code>DB_TAG_BOOT_TIME</code> Boot timestamp 0x0008 <code>DB_TAG_BOOTLOADER</code> Bootloader name/version 0x0009 <code>DB_TAG_KERNEL_FILE</code> Original kernel file info 0x000A <code>DB_TAG_EFI_SYSTEM_TABLE</code> EFI System Table pointer (if UEFI) 0x000B <code>DB_TAG_INITRD</code> Initial ramdisk (initrd/initramfs) 0x000C <code>DB_TAG_KERNEL_PHYS</code> Physical memory footprint of kernel 0x8000+ Vendor-specific Reserved for custom extensions"},{"location":"specs/boot/#tag-definitions","title":"Tag Definitions","text":""},{"location":"specs/boot/#db_tag_end-0x0000","title":"DB_TAG_END (0x0000)","text":"<p>Marks the end of the tag list. Required.</p> <pre><code>struct db_tag_end {\n    u16 type;           // 0x0000\n    u16 flags;          // 0\n    u32 size;           // 8\n};\n</code></pre>"},{"location":"specs/boot/#db_tag_cmdline-0x0001","title":"DB_TAG_CMDLINE (0x0001)","text":"<p>Null-terminated command line string.</p> <pre><code>struct db_tag_cmdline {\n    u16 type;           // 0x0001\n    u16 flags;          // 0\n    u32 size;           // 8 + string length + 1 (null terminator)\n    char cmdline[];     // Null-terminated UTF-8 string\n};\n</code></pre>"},{"location":"specs/boot/#db_tag_memory_map-0x0002","title":"DB_TAG_MEMORY_MAP (0x0002)","text":"<p>Describes physical memory layout.</p> <pre><code>struct db_tag_memory_map {\n    u16 type;           // 0x0002\n    u16 flags;          // 0\n    u32 size;           // Total tag size\n    u32 entry_size;     // Size of each entry (for forward compat)\n    u32 entry_count;    // Number of entries\n    struct db_mmap_entry entries[];\n};\n\nstruct db_mmap_entry {\n    u64 base;           // Physical base address\n    u64 length;         // Length in bytes\n    u32 type;           // Memory type (see below)\n    u32 attributes;     // Additional attributes\n};\n</code></pre> <p>Memory Types:</p> Value Name Description 0 <code>DB_MEM_RESERVED</code> Reserved, do not use 1 <code>DB_MEM_USABLE</code> Free RAM, available for use 2 <code>DB_MEM_ACPI_RECLAIMABLE</code> ACPI tables, reclaimable 3 <code>DB_MEM_ACPI_NVS</code> ACPI Non-Volatile Storage 4 <code>DB_MEM_BAD</code> Bad memory, do not use 5 <code>DB_MEM_BOOTLOADER</code> Used by bootloader, reclaimable 6 <code>DB_MEM_KERNEL</code> Kernel image 7 <code>DB_MEM_FRAMEBUFFER</code> Framebuffer memory 8 <code>DB_MEM_INITRD</code> Initial ramdisk, reclaimable 9 <code>DB_MEM_MODULES</code> Loaded modules"},{"location":"specs/boot/#db_tag_framebuffer-0x0003","title":"DB_TAG_FRAMEBUFFER (0x0003)","text":"<p>Framebuffer information for graphical output.</p> <pre><code>struct db_tag_framebuffer {\n    u16 type;           // 0x0003\n    u16 flags;          // 0\n    u32 size;           // Tag size\n    u64 address;        // Physical address of framebuffer\n    u32 width;          // Width in pixels\n    u32 height;         // Height in pixels\n    u32 pitch;          // Bytes per scanline\n    u8  bpp;            // Bits per pixel\n    u8  red_shift;      // Red component bit position\n    u8  red_size;       // Red component bit size\n    u8  green_shift;\n    u8  green_size;\n    u8  blue_shift;\n    u8  blue_size;\n    u8  reserved_shift;\n    u8  reserved_size;\n    u8  padding[3];     // Alignment padding\n};\n</code></pre>"},{"location":"specs/boot/#db_tag_modules-0x0004","title":"DB_TAG_MODULES (0x0004)","text":"<p>Loaded boot modules (initramfs, drivers, etc.).</p> <pre><code>struct db_tag_modules {\n    u16 type;           // 0x0004\n    u16 flags;          // 0\n    u32 size;           // Total tag size\n    u32 module_count;   // Number of modules\n    u32 reserved;\n    struct db_module modules[];\n};\n\nstruct db_module {\n    u64 start;          // Physical start address\n    u64 end;            // Physical end address (exclusive)\n    u32 name_offset;    // Offset to null-terminated name string (from tag start)\n    u32 cmdline_offset; // Offset to null-terminated cmdline (from tag start)\n};\n// Module names and cmdlines stored as strings after the module array\n</code></pre>"},{"location":"specs/boot/#db_tag_initrd-0x000b","title":"DB_TAG_INITRD (0x000B)","text":"<p>Initial ramdisk (initrd or initramfs)  This is the primary way to load a initial filesystem for early boot.</p> <pre><code>struct db_tag_initrd {\n    u16 type;           // 0x000B\n    u16 flags;          // 0\n    u32 size;           // Tag size\n    u64 start;          // Physical start address of initrd\n    u64 length;         // Size in bytes\n};\n</code></pre> <p>Notes: - The bootloader loads the initrd file into contiguous physical memory - The kernel is responsible for parsing the format (cpio, ext2, etc.) - Memory region is marked as <code>DB_MEM_INITRD</code> in the memory map (reclaimable after use)</p>"},{"location":"specs/boot/#db_tag_kernel_phys-0x000c","title":"DB_TAG_KERNEL_PHYS (0x000C)","text":"<p>Provides the exact physical memory footprint of the loaded kernel. This is used by the kernel to reserve its own physical pages in the memory manager.</p> <pre><code>struct db_tag_kernel_phys {\n    u16 type;           // 0x000C\n    u16 flags;          // 0\n    u32 size;           // Tag size (24)\n    u64 phys_base;      // Physical start address of kernel\n    u64 phys_length;    // Total length in bytes\n};\n</code></pre>"},{"location":"specs/boot/#db_tag_acpi_rsdp-0x0005","title":"DB_TAG_ACPI_RSDP (0x0005)","text":"<p>ACPI Root System Description Pointer.</p> <pre><code>struct db_tag_acpi_rsdp {\n    u16 type;           // 0x0005\n    u16 flags;          // Bit 0: set if XSDP (ACPI 2.0+)\n    u32 size;           // Tag size\n    u64 rsdp_address;   // Physical address of RSDP/XSDP\n};\n</code></pre>"},{"location":"specs/boot/#db_tag_smp-0x0006","title":"DB_TAG_SMP (0x0006)","text":"<p>Symmetric Multi Processing information.</p> <pre><code>struct db_tag_smp {\n    u16 type;           // 0x0006\n    u16 flags;          // 0\n    u32 size;           // Tag size\n    u32 cpu_count;      // Number of CPUs\n    u32 bsp_id;         // Bootstrap processor ID\n    struct db_cpu cpus[];\n};\n\nstruct db_cpu {\n    u32 id;             // CPU/APIC ID (arch-specific)\n    u32 flags;          // Bit 0: enabled, Bit 1: is BSP\n};\n</code></pre>"},{"location":"specs/boot/#db_tag_bootloader-0x0008","title":"DB_TAG_BOOTLOADER (0x0008)","text":"<p>Bootloader identification.</p> <pre><code>struct db_tag_bootloader {\n    u16 type;           // 0x0008\n    u16 flags;          // 0\n    u32 size;           // Tag size\n    char name[];        // Null-terminated bootloader name/version\n};\n</code></pre>"},{"location":"specs/boot/#minimal-kernel-example-pseudocode","title":"Minimal Kernel Example (Pseudocode)","text":"<pre><code>// Entry point receives db_boot_info pointer\nvoid kernel_main(struct db_boot_info* info) {\n    // Verify magic\n    if (info-&gt;magic != 0x44424F4B) {\n        panic(\"Not booted via DB protocol\");\n    }\n\n    // Iterate tags\n    struct db_tag* tag = (void*)info + sizeof(*info);\n\n    while (tag-&gt;type != DB_TAG_END) {\n        switch (tag-&gt;type) {\n            case DB_TAG_MEMORY_MAP:\n                parse_memory_map((struct db_tag_memory_map*)tag);\n                break;\n            case DB_TAG_FRAMEBUFFER:\n                init_framebuffer((struct db_tag_framebuffer*)tag);\n                break;\n            //... handle other tags\n        }\n\n        // Advance to next tag (8-byte aligned)\n        tag = (void*)tag + ((tag-&gt;size + 7) &amp; ~7);\n    }\n}\n</code></pre>"},{"location":"specs/boot/#bootloader-requirements","title":"Bootloader Requirements","text":"<p>A DB-compliant bootloader must:</p> <ol> <li>Locate the DB Request Header in the kernel binary (first 32 KiB, 8-byte aligned)</li> <li>Verify the magic (<code>0x44420001</code>)</li> <li>Load the kernel into memory at an appropriate address (bootloader's choice)</li> <li>Prepare DB Boot Info with requested tags based on request flags</li> <li>Set up machine state:</li> <li>Interrupts disabled</li> <li>Paging enabled with identity mapping (virtual = physical)</li> <li>A20 line enabled (if x86)</li> <li>Pass boot info pointer in the architecture-defined register</li> <li>Jump to kernel entry point</li> </ol>"},{"location":"specs/boot/#load-address","title":"Load Address","text":"<p>The bootloader chooses where to load the kernel in physical memory. The kernel must be position-independent or linked to expect this. The kernel can determine its load address from the memory map (look for <code>DB_MEM_KERNEL</code> regions).</p>"},{"location":"specs/exec/","title":"Delta Executable Format (DX)","text":""},{"location":"specs/exec/#overview","title":"Overview","text":"<p>DX is the native executable format for DeltaOS  simpler than ELF/PE/Mach-O while still supporting:</p> <ul> <li>Position-independent code</li> <li>Dynamic linking</li> <li>Multiple architectures</li> </ul> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  DX Header (magic, version, arch)       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Segment Table                          \u2502\n\u2502  - Code segment                         \u2502\n\u2502  - Data segment                         \u2502\n\u2502  - ...                                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Symbol Table (optional)                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Relocation Table (optional)            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Raw segment data                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"specs/exec/#data-types","title":"Data Types","text":"<p>All multi-byte integers are little-endian.</p> Type Size Description <code>u8</code> 1 byte Unsigned 8-bit <code>u16</code> 2 bytes Unsigned 16-bit LE <code>u32</code> 4 bytes Unsigned 32-bit LE <code>u64</code> 8 bytes Unsigned 64-bit LE"},{"location":"specs/exec/#dx-header","title":"DX Header","text":"<p>The header is split into a common part (architecture-independent) followed by an architecture-specific part. The <code>header_size</code> field indicates total size.</p>"},{"location":"specs/exec/#common-header","title":"Common Header","text":"<pre><code>struct dx_header {\n    u32 magic;          // 0x44580001 ('D' 'X' 0x00 0x01)\n    u32 checksum;       // CRC32 of file (with this field as 0)\n    u16 version;        // Format version (0x0001)\n    u16 type;           // Executable type (see below)\n    u16 arch;           // Target architecture\n    u16 flags;          // Executable flags\n    u16 header_size;    // Total header size (common + arch)\n    u16 reserved;       // Must be zero (reject if non-zero)\n    u32 segment_off;    // Offset to segment table\n    u16 segment_count;  // Number of segments\n    u16 segment_size;   // Size of each segment entry\n    u32 symbol_off;     // Offset to symbol table (0 = none)\n    u32 symbol_count;   // Number of symbols\n    u32 strtab_off;     // Offset to string table\n    u32 strtab_size;    // Size of string table in bytes\n    u32 reloc_off;      // Offset to relocation table (0 = none)\n    u32 reloc_count;    // Number of relocations\n    u32 prelink_off;    // Offset to prelink cache (0 = none)\n    // Architecture-specific part follows immediately\n};\n</code></pre> <p>Common size: 56 bytes</p> <p>Reserved fields: All <code>reserved</code> fields MUST be zero. Loaders MUST reject files with non-zero reserved fields. This allows clean version bumps.</p>"},{"location":"specs/exec/#architecture-specific-header","title":"Architecture-Specific Header","text":"<p>Rule: The arch-specific part MUST be a strict extension of the common header. No reordering, no conditional fields, no shared offsets. This ensures cross-arch tools can parse the common header without knowing the architecture.</p>"},{"location":"specs/exec/#amd64-so-64-bit","title":"AMD64 (so 64-bit)","text":"<pre><code>struct dx_header_amd64 {\n    u64 entry;          // Entry point (virtual address, or offset if PIE)\n};\n</code></pre> <p>Total header size (AMD64): 64 bytes (56 + 8)</p>"},{"location":"specs/exec/#x86-so-32-bit","title":"x86 (so 32-bit)","text":"<pre><code>struct dx_header_x86 {\n    u32 entry;          // Entry point\n};\n</code></pre> <p>Total header size (x86): 60 bytes (56 + 4)</p> <p>Note: For PIE executables, add the load base to entry to get actual address.</p>"},{"location":"specs/exec/#magic","title":"Magic","text":"<p><code>0x44580001</code>: - <code>0x44</code> = 'D' - <code>0x58</code> = 'X' - <code>0x00</code> = separator - <code>0x01</code> = version</p>"},{"location":"specs/exec/#type","title":"Type","text":"Value Name Description 0 <code>DX_EXEC</code> Executable 1 <code>DX_DYN</code> Dynamic library (shared object) 2 <code>DX_OBJ</code> Relocatable object file"},{"location":"specs/exec/#architecture","title":"Architecture","text":"Value Name Arch Header Size Description 0 <code>DX_ARCH_ANY</code> 0 Architecture-independent 1 <code>DX_ARCH_AMD64</code> 8 x86-64 2 <code>DX_ARCH_X86</code> 4 x86 (32-bit) 3 <code>DX_ARCH_ARM64</code> 8 AArch64 4 <code>DX_ARCH_ARM32</code> 4 ARM (32-bit) 5 <code>DX_ARCH_RISCV64</code> 8 RISC-V 64-bit"},{"location":"specs/exec/#flags","title":"Flags","text":"Bit Name Description 0 <code>DX_FLAG_PIE</code> Position-independent executable 1 <code>DX_FLAG_STATIC</code> Statically linked 2 <code>DX_FLAG_DEBUG</code> Contains debug information 3 <code>DX_FLAG_LAZY</code> Lazy symbol resolution (resolve on first call)"},{"location":"specs/exec/#segment-table","title":"Segment Table","text":"<p>Each segment describes a contiguous region to load.</p> <pre><code>struct dx_segment {\n    u32 type;           // Segment type\n    u32 flags;          // Permissions (RWX)\n    u64 file_off;       // Offset in file\n    u64 file_size;      // Size in file (may be 0 for BSS)\n    u64 mem_addr;       // Virtual address (or offset if PIE)\n    u64 mem_size;       // Size in memory (&gt;= file_size for BSS)\n    u64 align;          // Alignment requirement\n};\n</code></pre> <p>Size: 48 bytes</p>"},{"location":"specs/exec/#segment-types","title":"Segment Types","text":"Value Name Description 0 <code>DX_SEG_NULL</code> Unused entry 1 <code>DX_SEG_LOAD</code> Loadable segment 2 <code>DX_SEG_DYN</code> Dynamic linking info 3 <code>DX_SEG_NOTE</code> Note/comment"},{"location":"specs/exec/#segment-flags-permissions","title":"Segment Flags (Permissions)","text":"Bit Name Description 0 <code>R</code> Readable 1 <code>W</code> Writable 2 <code>X</code> Executable"},{"location":"specs/exec/#symbol-table","title":"Symbol Table","text":"<p>For dynamic linking and debugging.</p> <pre><code>struct dx_symbol {\n    u32 name_off;       // Offset to name string (in string table)\n    u16 type;           // Symbol type\n    u16 bind;           // Binding (local/global/weak)\n    u64 value;          // Value (address or offset)\n    u64 size;           // Size of symbol\n    u16 segment;        // Segment index (0xFFFF = absolute)\n    u16 reserved;\n};\n</code></pre> <p>Size: 28 bytes</p>"},{"location":"specs/exec/#symbol-types","title":"Symbol Types","text":"Value Name Description 0 <code>DX_SYM_NONE</code> No type 1 <code>DX_SYM_FUNC</code> Function 2 <code>DX_SYM_DATA</code> Data object 3 <code>DX_SYM_SECTION</code> Section"},{"location":"specs/exec/#symbol-binding","title":"Symbol Binding","text":"Value Name Description 0 <code>DX_BIND_LOCAL</code> Not visible outside file 1 <code>DX_BIND_GLOBAL</code> Visible, can be resolved 2 <code>DX_BIND_WEAK</code> Weak symbol"},{"location":"specs/exec/#relocation-table","title":"Relocation Table","text":"<p>For position-independent code.</p> <pre><code>struct dx_reloc {\n    u64 offset;         // Offset to apply relocation\n    u16 type;           // Relocation type (arch-specific)\n    u16 segment;        // Segment containing the offset\n    u32 symbol;         // Symbol index (or 0 for relative)\n    i64 addend;         // Addend for calculation\n};\n</code></pre> <p>Size: 24 bytes</p>"},{"location":"specs/exec/#relocation-types-amd64","title":"Relocation Types (AMD64)","text":"Value Name Calculation 0 <code>DX_R_NONE</code> None 1 <code>DX_R_64</code> S + A 2 <code>DX_R_PC32</code> S + A - P 3 <code>DX_R_PLT32</code> L + A - P 4 <code>DX_R_RELATIVE</code> B + A <p>Where: S = symbol value, A = addend, P = place, B = base address and L = PLT entry</p>"},{"location":"specs/exec/#string-table","title":"String Table","text":"<p>Zero-terminated strings, referenced by offset.</p>"},{"location":"specs/exec/#loading-algorithm","title":"Loading Algorithm","text":"<pre><code>int dx_load(void *file, size_t size, uintptr load_base) {\n    struct dx_header *hdr = file;\n\n    // Verify magic and version\n    if (hdr-&gt;magic != 0x44580001) return -1;\n    if (hdr-&gt;arch != DX_ARCH_AMD64) return -1;\n\n    // Load segments\n    struct dx_segment *segs = file + hdr-&gt;segment_off;\n    for (int i = 0; i &lt; hdr-&gt;segment_count; i++) {\n        if (segs[i].type != DX_SEG_LOAD) continue;\n\n        uintptr dest = segs[i].mem_addr;\n        if (hdr-&gt;flags &amp; DX_FLAG_PIE) dest += load_base;\n\n        mmap((void *)dest, segs[i].mem_size, segs[i].flags);\n        memcpy((void *)dest, file + segs[i].file_off, segs[i].file_size);\n        memset((void *)(dest + segs[i].file_size), 0, \n               segs[i].mem_size - segs[i].file_size);\n    }\n\n    // Apply relocations (if PIE)\n    if (hdr-&gt;flags &amp; DX_FLAG_PIE) {\n        apply_relocations(file, hdr, load_base);\n    }\n\n    // Jump to entry point (add base for PIE)\n    uintptr entry_addr = hdr-&gt;entry;\n    if (hdr-&gt;flags &amp; DX_FLAG_PIE) entry_addr += load_base;\n\n    void (*entry)(void) = (void *)entry_addr;\n    entry();\n}\n</code></pre>"},{"location":"specs/exec/#comparison-to-other-formats","title":"Comparison to Other Formats","text":"Feature DX ELF PE Mach-O Header size 56-64B 64B+ 248B+ 32B+ Fixed tables Yes No No No Section names No Yes Yes Yes Segment/Section Merged Separate Separate Separate Prelink cache Yes No No No Lazy binding Yes Yes Yes Yes Checksum CRC32 Optional Yes Optional Complexity Low Medium High High"},{"location":"specs/exec/#notes","title":"Notes","text":"<ul> <li>ELF compatibility: DeltaOS will support ELF during transition for toolchain compatibility</li> <li>Future extensions: Types 0x8000+ reserved for extensions</li> </ul>"},{"location":"specs/exec/#checksum","title":"Checksum","text":"<p>The <code>checksum</code> field contains a CRC32 (polynomial <code>0xEDB88320</code>) of the entire file, with the <code>checksum</code> field itself treated as zero during computation.</p> <p>Verification is optional \u2014 loaders may skip for speed when loading from trusted sources. System libraries can skip verification; untrusted executables should verify.</p>"},{"location":"specs/exec/#prelink-cache","title":"Prelink Cache","text":"<p>The prelink cache stores pre-resolved symbol addresses for faster loading. When <code>prelink_off</code> is non-zero, it points to:</p> <pre><code>struct dx_prelink {\n    u32 count;              // Number of cached entries\n    u32 base_valid;         // 1 if cache matches current library layout\n    u64 base_addr;          // Base address cache was computed for\n    struct dx_prelink_entry entries[];\n};\n\nstruct dx_prelink_entry {\n    u32 symbol;             // Symbol index\n    u32 reserved;           // Padding for alignment\n    u64 resolved_addr;      // Pre-resolved address\n};\n</code></pre> <p>Usage: - If <code>base_valid</code> and libraries haven't changed, use cached addresses directly - Otherwise, fall back to normal symbol resolution - Tools like <code>dx-prelink</code> regenerate cache when system libraries update</p>"},{"location":"specs/exec/#lazy-binding","title":"Lazy Binding","text":"<p>When <code>DX_FLAG_LAZY</code> is set, external symbols are resolved on first call:</p> <ol> <li>PLT entries initially point to resolver stub</li> <li>First call invokes resolver, patches PLT with real address</li> <li>Subsequent calls go directly to resolved address</li> </ol> <p>This speeds up startup by deferring work, until actually needed.</p>"},{"location":"specs/media/","title":"Delta Media Format (DM)","text":""},{"location":"specs/media/#overview","title":"Overview","text":"<p>DM is the native media format for DeltaOS, designed for:</p> <ul> <li>Fast decoding \u2014 Simple compression, bounded memory usage</li> <li>Safe parsing \u2014 Explicit validation, no undefined behavior</li> <li>Extensibility \u2014 Reserved fields for future versions</li> </ul> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  DM Header (magic, type, dimensions)    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Type-specific Header                   \u2502\n\u2502  (image/video/audio parameters)         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Data Section                           \u2502\n\u2502  (pixels, samples, or frames)           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"specs/media/#data-types","title":"Data Types","text":"<p>All multi-byte integers are little-endian.</p> Type Size Description <code>u8</code> 1 byte Unsigned 8-bit <code>u16</code> 2 bytes Unsigned 16-bit LE <code>u32</code> 4 bytes Unsigned 32-bit LE <code>u64</code> 8 bytes Unsigned 64-bit LE"},{"location":"specs/media/#dm-header","title":"DM Header","text":"<p>Common header for all media types</p> <pre><code>struct dm_header {\n    u32 magic;          // 0x444D0001 ('D' 'M' 0x00 0x01)\n    u32 checksum;       // CRC32 of entire file (with this field as 0)\n    u16 version;        // Format version (0x0001)\n    u8  type;           // Media type (0-2, reject others)\n    u8  compression;    // Compression method (0-1, reject others)\n    u32 header_size;    // Total header size (common + type-specific)\n    u64 data_offset;    // Offset to daa section from file start\n    u64 data_size;      // Size of data section in bytes (compressed)\n    u64 raw_size;       // Size of uncompressed data (for allocation)\n};\n</code></pre> <p>Size: 40 bytes Alignment: DM files MUST be mapped at 8-byte aligned addresses.</p>"},{"location":"specs/media/#magic","title":"Magic","text":"<p><code>0x444D0001</code>: - <code>0x44</code> = 'D' - <code>0x4D</code> = 'M' - <code>0x00</code> = separator - <code>0x01</code> = version</p>"},{"location":"specs/media/#media-types","title":"Media Types","text":"Value Name Description 0 <code>DM_TYPE_IMAGE</code> Static image 1 <code>DM_TYPE_VIDEO</code> Video (sequence of frames) 2 <code>DM_TYPE_AUDIO</code> Audio stream <p>[!IMPORTANT] Parsers MUST reject files with <code>type &gt;= 3</code>. Unknown types are errors not extensions.</p>"},{"location":"specs/media/#compression-methods","title":"Compression Methods","text":"Value Name Description 0 <code>DM_COMP_NONE</code> Uncompressed (raw data) 1 <code>DM_COMP_RLE</code> Run-length encoding <p>[!IMPORTANT] Parsers MUST reject files with <code>compression &gt;= 2</code>, future versions may add LZ4.</p>"},{"location":"specs/media/#pixel-formats","title":"Pixel Formats","text":"<p>Used by image and video types.</p> Value Name BPP Description 0 <code>DM_PIXEL_RGB24</code> 3 8-bit R, G, B (sRGB) 1 <code>DM_PIXEL_RGBA32</code> 4 8-bit R, G, B, A (sRGB, premul) 2 <code>DM_PIXEL_BGR24</code> 3 8-bit B, G, R (sRGB) 3 <code>DM_PIXEL_BGRA32</code> 4 8-bit B, G, R, A (sRGB, premul) 4 <code>DM_PIXEL_GRAY8</code> 1 8-bit grayscale (sRGB luminance) <p>[!NOTE] All pixel formats use sRGB color space and transfer function. Alpha is premultiplied. (color values already scaled by alpha)</p>"},{"location":"specs/media/#bytes-per-pixel-lookup","title":"Bytes Per Pixel Lookup","text":"<pre><code>static inline u8 dm_pixel_bpp(u8 format) {\n    static const u8 bpp[] = { 3, 4, 3, 4, 1 };  // RGB24, RGBA32, BGR24, BGRA32, GRAY8\n    return (format &lt; 5) ? bpp[format] : 0;\n}\n</code></pre>"},{"location":"specs/media/#type-specific-headers","title":"Type-Specific Headers","text":""},{"location":"specs/media/#image-header-type-0","title":"Image Header (type = 0)","text":"<pre><code>struct dm_image_header {\n    u32 width;          // Width in pixels (1-16384)\n    u32 height;         // Height in pixels (1-16384)\n    u8  pixel_format;   // Pixel format (0-4, reject others)\n    u8  transfer;       // Transfer function (0=sRGB, reserved 1-255)\n    u8  reserved[2];    // Must be zero, reject if non-zero\n};\n</code></pre> <p>Size: 12 bytes Total header (image): 52 bytes (40 + 12)</p> <p>Validation requirements: - <code>width &gt;= 1 &amp;&amp; width &lt;= 16384</code> - <code>height &gt;= 1 &amp;&amp; height &lt;= 16384</code> - <code>pixel_format &lt;= 4</code> - <code>transfer == 0</code> (reject non-zero for v1) - <code>reserved[0] == 0 &amp;&amp; reserved[1] == 0</code></p> <p>Data section: Raw pixel data, row-major order (top-left origin). Each row is tightly packed (no padding between rows)</p>"},{"location":"specs/media/#video-header-type-1","title":"Video Header (type = 1)","text":"<pre><code>struct dm_video_header {\n    u32 width;          // Frame width in pixels (1-16384)\n    u32 height;         // Frame height in pixels (1-16384)\n    u32 frame_count;    // Total number of frames (0 = unknown/streaming)\n    u32 fps_num;        // Framerate numerator (1-1000000)\n    u32 fps_den;        // Framerate denominator (1-1000000, e.g., 1001 for 23.976)\n    u8  pixel_format;   // Pixel format (0-4, reject others)\n    u8  flags;          // Video flags (see below)\n    u8  transfer;       // Transfer function (0=sRGB)\n    u8  reserved;       // Must be zero\n};\n</code></pre> <p>Size: 24 bytes Total header (video): 64 bytes (40 + 24)</p> <p>Validation requirements: - <code>fps_num &gt;= 1 &amp;&amp; fps_num &lt;= 1000000</code> - <code>fps_den &gt;= 1 &amp;&amp; fps_den &lt;= 1000000</code></p> <p>[!IMPORTANT] <code>fps_den</code> MUST be &gt;= 1. Division by zero is undefined behavior.</p> <p>Video Flags:</p> Bit Name Description 0 <code>DM_VID_LOOP</code> Video should loop <p>Data section: Frames stored sequentially. Each frame is: - <code>width * height * bpp</code> bytes (uncompressed) - Or RLE-compressed (each frame compressed independently)</p> <p>[!WARNING] No intra-frame seeking. To decode frame N, all frames 0..N-1 must be decoded. This format is NOT suitable for long-form video content.</p>"},{"location":"specs/media/#audio-header-type-2","title":"Audio Header (type = 2)","text":"<pre><code>struct dm_audio_header {\n    u32 sample_rate;    // Samples per second (8000-192000)\n    u32 sample_count;   // Total samples per channel (0 = streaming)\n    u8  channels;       // Number of channels (1=mono, 2=stereo)\n    u8  bits_per_sample;// 16 or 32 only (reject others)\n    u8  format;         // Sample format (see below)\n    u8  reserved;       // Must be zero\n};\n</code></pre> <p>Size: 12 bytes Total header (audio): 52 bytes (40 + 12)</p> <p>Sample Formats:</p> Value Name Description 0 <code>DM_AUDIO_PCM</code> Signed PCM (little-endian) 1 <code>DM_AUDIO_FLOAT</code> IEEE 754 float (32-bit only) <p>Validation requirements: - <code>channels == 1 || channels == 2</code> (v1 supports mono/stereo only) - <code>bits_per_sample == 16 || bits_per_sample == 32</code> - <code>sample_rate &gt;= 8000 &amp;&amp; sample_rate &lt;= 192000</code></p> <p>[!IMPORTANT] <code>bits_per_sample</code> MUST be 16 or 32. 8-bit and 24-bit are NOT supported (8-bit has poor quality ans 24-bit causes alignment issues).</p> <p><code>channels</code> &gt; 2 is reserved for future versions. Reject for v1.</p> <p>Data section: Interleaved samples. For stereo: <code>L0 R0 L1 R1 L2 R2 ...</code></p> <p>Channel layout: - 1 channel: Mono - 2 channels: Left, Right</p>"},{"location":"specs/media/#rle-compression","title":"RLE Compression","text":"<p>Run-length encoding operates on pixels. Format:</p> <pre><code>[count][pixel_data]...\n</code></pre> <p>Where: - <code>count</code> (u8): Number of times to repeat (1-255, 0 is invalid) - <code>pixel_data</code>: One pixel in the file's pixel format</p> <p>Example (RGBA32): <pre><code>Input:  AAAA AAAA BBBB CCCC CCCC CCCC  (6 pixels, 24 bytes)\nRLE:    04 AAAA 01 BBBB 03 CCCC        (15 bytes)\n</code></pre></p> <p>Decoder with full validation: <pre><code>int dm_rle_decode(const u8 *src, size_t src_size,\n                  u8 *dst, size_t dst_size, u8 bpp) {\n    size_t src_pos = 0, dst_pos = 0;\n\n    while (dst_pos &lt; dst_size) {\n        // Check bounds on count byte\n        if (src_pos &gt;= src_size) return -1;\n        u8 count = src[src_pos++];\n\n        // Reject count == 0 (invalid)\n        if (count == 0) return -1;\n\n        // Check bounds on pixel data\n        if (src_pos + bpp &gt; src_size) return -1;\n\n        // Check output won't overflow\n        if ((size_t)count * bpp &gt; dst_size - dst_pos) return -1;\n\n        // Copy pixel 'count' times\n        for (u8 i = 0; i &lt; count; i++) {\n            memcpy(dst + dst_pos, src + src_pos, bpp);\n            dst_pos += bpp;\n        }\n        src_pos += bpp;\n    }\n\n    return 0;\n}\n</code></pre></p>"},{"location":"specs/media/#loading-algorithm","title":"Loading Algorithm","text":""},{"location":"specs/media/#safe-image-loading","title":"Safe Image Loading","text":"<pre><code>int dm_load_image(const void *file, size_t file_size, dm_image_t *out,\n                  void *(*alloc)(size_t), void (*dealloc)(void *)) {\n    if (file_size &lt; sizeof(struct dm_header)) return DM_ERR_TRUNCATED;\n\n    const struct dm_header *hdr = file;\n\n    // Verify magic and type\n    if (hdr-&gt;magic != 0x444D0001) return DM_ERR_MAGIC;\n    if (hdr-&gt;type != DM_TYPE_IMAGE) return DM_ERR_TYPE;\n    if (hdr-&gt;type &gt;= 3) return DM_ERR_UNKNOWN_TYPE;\n    if (hdr-&gt;compression &gt;= 2) return DM_ERR_UNKNOWN_COMP;\n\n    // Validate header_size\n    if (hdr-&gt;header_size &lt; sizeof(*hdr) + sizeof(struct dm_image_header))\n        return DM_ERR_HEADER;\n    if (hdr-&gt;header_size &gt; file_size) return DM_ERR_TRUNCATED;\n\n    const struct dm_image_header *img = (const void *)((const u8 *)file + sizeof(*hdr));\n\n    // Validate dimensions\n    if (img-&gt;width == 0 || img-&gt;width &gt; 16384) return DM_ERR_DIMENSIONS;\n    if (img-&gt;height == 0 || img-&gt;height &gt; 16384) return DM_ERR_DIMENSIONS;\n    if (img-&gt;pixel_format &gt; 4) return DM_ERR_PIXEL_FORMAT;\n    if (img-&gt;transfer != 0) return DM_ERR_UNSUPPORTED;\n    if (img-&gt;reserved[0] != 0 || img-&gt;reserved[1] != 0) return DM_ERR_RESERVED;\n\n    // Validate data bounds\n    if (hdr-&gt;data_offset &gt; file_size) return DM_ERR_TRUNCATED;\n    if (hdr-&gt;data_size &gt; file_size - hdr-&gt;data_offset) return DM_ERR_TRUNCATED;\n\n    // OVERFLOW-SAFE size calculation\n    u8 bpp = dm_pixel_bpp(img-&gt;pixel_format);\n    if (bpp == 0) return DM_ERR_PIXEL_FORMAT;  // Unknown format\n\n    if (img-&gt;width &gt; SIZE_MAX / bpp) return DM_ERR_OVERFLOW;\n    size_t row_size = (size_t)img-&gt;width * bpp;\n\n    // row_size == 0 is impossible here (width &gt;= 1, bpp &gt;= 1)\n    if (img-&gt;height &gt; SIZE_MAX / row_size) return DM_ERR_OVERFLOW;\n    size_t raw_size = row_size * img-&gt;height;\n\n    // Validate raw_size matches header\n    if (hdr-&gt;raw_size != raw_size) return DM_ERR_SIZE_MISMATCH;\n\n    out-&gt;width = img-&gt;width;\n    out-&gt;height = img-&gt;height;\n    out-&gt;bpp = bpp;\n    out-&gt;pixels = alloc(raw_size);\n    if (!out-&gt;pixels) return DM_ERR_OOM;\n\n    const u8 *data = (const u8 *)file + hdr-&gt;data_offset;\n\n    if (hdr-&gt;compression == DM_COMP_NONE) {\n        if (hdr-&gt;data_size != raw_size) {\n            dealloc(out-&gt;pixels);\n            return DM_ERR_SIZE_MISMATCH;\n        }\n        memcpy(out-&gt;pixels, data, raw_size);\n    } else if (hdr-&gt;compression == DM_COMP_RLE) {\n        if (dm_rle_decode(data, hdr-&gt;data_size, out-&gt;pixels, raw_size, bpp) != 0) {\n            dealloc(out-&gt;pixels);\n            return DM_ERR_DECODE;\n        }\n    }\n\n    return DM_OK;\n}\n</code></pre>"},{"location":"specs/media/#error-codes","title":"Error Codes","text":"Value Name Description 0 <code>DM_OK</code> Success -1 <code>DM_ERR_TRUNCATED</code> File too small -2 <code>DM_ERR_MAGIC</code> Invalid magic number -3 <code>DM_ERR_TYPE</code> Wrong media type -4 <code>DM_ERR_UNKNOWN_TYPE</code> Unknown type (reject) -5 <code>DM_ERR_UNKNOWN_COMP</code> Unknown compression (reject) -6 <code>DM_ERR_HEADER</code> Header size invalid -7 <code>DM_ERR_DIMENSIONS</code> Invalid dimensions -8 <code>DM_ERR_PIXEL_FORMAT</code> Unknown pixel format -9 <code>DM_ERR_UNSUPPORTED</code> Unsupported feature (reserved) -10 <code>DM_ERR_RESERVED</code> Non-zero reserved field -11 <code>DM_ERR_OVERFLOW</code> Size calculation overflow -12 <code>DM_ERR_SIZE_MISMATCH</code> Data size doesn't match -13 <code>DM_ERR_OOM</code> Allocation failed -14 <code>DM_ERR_DECODE</code> Decompression error"},{"location":"specs/media/#comparison-to-other-formats-as-always","title":"Comparison to Other Formats (as always)","text":"Feature DM PNG BMP stb_image Header size 40-64B Variable 54B+ N/A Dependencies None zlib None None Compression RLE DEFLATE RLE N/A Alpha channel Yes Yes Limited Yes Code complexity ~200 LOC ~8K LOC ~100 LOC ~7K LOC"},{"location":"specs/media/#security-checklist","title":"Security Checklist","text":"<p>Decoders MUST implement ALL of these checks:</p> <ul> <li>[ ] <code>magic == 0x444D0001</code></li> <li>[ ] <code>type &lt; 3</code> (reject unknown)</li> <li>[ ] <code>compression &lt; 2</code> (reject unknown)</li> <li>[ ] <code>header_size &gt;= minimum for type</code></li> <li>[ ] <code>header_size &lt;= file_size</code></li> <li>[ ] <code>data_offset + data_size &lt;= file_size</code></li> <li>[ ] <code>width &gt;= 1 &amp;&amp; width &lt;= 16384</code></li> <li>[ ] <code>height &gt;= 1 &amp;&amp; height &lt;= 16384</code></li> <li>[ ] <code>pixel_format</code> in valid range</li> <li>[ ] <code>reserved</code> fields are zero</li> <li>[ ] Verify <code>fps_num &gt;= 1 &amp;&amp; fps_den &gt;= 1</code> before division</li> <li>[ ] Verify <code>channels &lt;= 2</code> (v1 limit)</li> <li>[ ] Verify <code>sample_rate &lt;= 192000</code></li> <li>[ ] Verify <code>data_offset</code> is 8-byte aligned</li> <li>[ ] Verify <code>raw_size</code> matches computed size</li> <li>[ ] RLE count != 0</li> <li>[ ] RLE input bounds checked</li> <li>[ ] RLE output bounds checked</li> </ul> <p>[!CAUTION] Checksum validation is NOT optional. DM files, may come from untrusted sources (like downloads, USB drives). Always verify CRC32 before parsing.</p>"},{"location":"specs/media/#notes","title":"Notes","text":"<ul> <li>sRGB only: All colors are sRGB. No colorspace negotiation.</li> <li>No metadata: Use separate files for EXIF/XMP.</li> <li>No streaming video: For boot splashes and icons only.</li> </ul>"}]}